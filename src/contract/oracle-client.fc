_ load_data() inline {
  slice ds = get_data().begin_parse();
  int actual_value = ds~load_uint(64);

  var addresses = ds~load_ref().begin_parse();
  slice owner_address = addresses~load_msg_addr(); 
  slice master_address = addresses~load_msg_addr();
  slice sc_address = addresses~load_msg_addr();

  int comission_size = ds~load_coins();
  cell whitelisted_oracle_addresses = ds~load_ref().begin_parse().preload_dict();
  int mode = ds~load_uint(32);
  int interval = ds~load_uint(32);
  int client_id = ds~load_uint(32);

  return (
    actual_value,
    owner_address,
    master_address,
    sc_address,
    comission_size,
    whitelisted_oracle_addresses,
    mode,
    interval,
    client_id 
  );
}

_ load_init_data () inline {
  slice ds = get_data().begin_parse();
  slice master_address = ds~load_msg_addr();
  int client_id = ds~load_uint(32);

  return (
    master_address, 
    client_id
  );
}

() save_data (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval, int client_id) impure {
  cell data = begin_cell()
      .store_uint(actual_value, 64)
      .store_ref(begin_cell().store_slice(owner_address).store_slice(master_address).store_slice(sc_address).end_cell())
      .store_coins(comission_size)
      .store_ref(begin_cell().store_dict(whitelisted_oracle_addresses).end_cell())
      .store_uint(mode, 32)
      .store_uint(interval, 32)
      .store_uint(client_id, 32)
    .end_cell();
  set_data(data);
  return();
}

() compose_comission_payment (slice comission_address, int comission_size) {
  cell comission_message = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(comission_address)
      .store_coins(comission_size)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .end_cell();
  send_raw_message(comission_message, 64); ;; pay fees
}

() compose_update_message ( int query_id, int actual_value, slice sc_address) {
  cell update_msg_body = begin_cell().store_uint(op::update(), 32).store_uint(query_id, 64).store_uint(actual_value, 64).end_cell();
  cell update_message = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sc_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_uint(1, 1)
        .store_ref(update_msg_body)
        .end_cell();
  send_raw_message(update_message, 64); 
}

() compose_withdrawal (slice sender_address) {
  cell mssage = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(sender_address)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell();
  send_raw_message(mssage, 128); ;; withdrawal entire balance
}

() recv_internal (int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
      return ();
  }

  slice cs = in_msg.begin_parse();
  int flags = cs~load_uint(4);
  
  if (flags & 1) {
      ;; TODO: Finish logic of on bounce
      ;; on_bounce(in_msg_body, msg_value);
      ;; in theory "throw(0xffff)" will be enougth
      return ();
  }

  [int balance, cell balance_cell] = get_balance();
  
  slice sender_address = cs~load_msg_addr();
  var (wc, addr_hash) = parse_std_addr(sender_address);
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);
  
  if (op == op::create_account()) {
    (slice master_address, int client_id) = load_init_data();
  
    throw_unless(103, sender_address.slice_hash() == master_address.slice_hash()); ;; permission denied

    slice addresses = in_msg_body~load_ref().begin_parse();
    slice owner_address = addresses~load_msg_addr();
    slice master_address = addresses~load_msg_addr();
    slice sc_address = addresses~load_msg_addr();
    int comission_size = in_msg_body~load_coins();
    cell whitelisted_oracle_addresses = in_msg_body~load_ref();
    int mode = in_msg_body~load_uint(32);
    int interval = in_msg_body~load_uint(32);
    int actual_value = in_msg_body~load_uint(64);
    
    save_data(actual_value, owner_address, master_address, sc_address, comission_size, whitelisted_oracle_addresses, mode, interval, client_id); 

    return();
  }
  
  (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval, int client_id) = load_data();

  if (op == op::new_value()) {
    throw_unless(103, sender_address.slice_hash() == master_address.slice_hash()); ;; permission denied
    int actual_value = in_msg_body~load_uint(64);
    save_data(actual_value, owner_address, master_address, sc_address, comission_size, whitelisted_oracle_addresses, mode, interval, client_id); 
    return();
  }

  if (op == op::fetch()) {
    throw_unless(103, sender_address.slice_hash() == sc_address.slice_hash()); ;; permission denied
    throw_if(101, balance < comission_size); ;; insufficient funds
    
    ;; TODO: none of 2 transactions are getting sent, must be debugged
    compose_comission_payment(master_address, comission_size);
    compose_update_message(query_id, actual_value, sc_address);
    
    return();
  }

  if (op == op::withdrawal()) {
    throw_unless(103, sender_address.slice_hash() == sc_address.slice_hash()); ;; permission denied 
    compose_withdrawal(sender_address); ;; TODO change withdrawal to 64 code maybe
    return();
  }

  throw(0xffff);
}

(int) get_actual_value() method_id {
  (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval, int client_id) = load_data();  
  return (actual_value);
}
