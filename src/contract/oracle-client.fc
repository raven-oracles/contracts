_ load_data() inline {
  slice ds = get_data().begin_parse();
  int actual_value = ds~load_uint(64);

  var addresses = ds~load_ref().begin_parse();
  slice owner_address = addresses~load_msg_addr(); 
  slice master_address = addresses~load_msg_addr();
  slice sc_address = addresses~load_msg_addr();

  int comission_size = ds~load_coins();
  cell whitelisted_oracle_addresses = ds~load_ref().begin_parse().preload_dict();
  int mode = ds~load_uint(32);
  int interval = ds~load_uint(32);

  return (
    actual_value,
    owner_address,
    master_address,
    sc_address,
    comission_size,
    whitelisted_oracle_addresses,
    mode,
    interval
  );
}

() save_data (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval) impure {
  cell data = begin_cell()
      .store_uint(actual_value, 64)
      .store_ref(begin_cell().store_slice(owner_address).store_slice(master_address).store_slice(sc_address).end_cell())
      .store_coins(comission_size)
      .store_ref(begin_cell().store_dict(whitelisted_oracle_addresses).end_cell())
      .store_uint(mode, 32)
      .store_uint(interval, 32)
      .end_cell();
  set_data(data);
  return();
}

() compose_comission_payment (slice comission_address, int comission_size) {
  cell comission_message = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(comission_address)
      .store_coins(comission_size)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .end_cell();
  send_raw_message(comission_message, 64); ;; pay fees
}

() compose_update_message ( int query_id, int actual_value, slice sc_address) {
  cell update_msg_body = begin_cell().store_uint(op::update(), 32).store_uint(query_id, 64).store_uint(actual_value, 64).end_cell();
  cell update_message = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sc_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_uint(1, 1)
        .store_ref(update_msg_body)
        .end_cell();
  send_raw_message(update_message, 64); 
}

() recv_internal (int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }
  
  [int balance, cell balance_cell] = get_balance();

  slice cs = in_msg.begin_parse();
  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  var (wc, addr_hash) = parse_std_addr(sender_address);
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval) = load_data();  

  if (op == op::new_value()) {
    var (_, address_allowed?) = whitelisted_oracle_addresses.udict_get?(256, addr_hash);
    throw_unless(103, address_allowed?); ;; permission denied
    int actual_value = in_msg_body~load_uint(64);
    save_data(actual_value, owner_address, master_address, sc_address, comission_size, whitelisted_oracle_addresses, mode, interval); 
    return();
  }

  if (op == op::fetch()) {
    throw_if(101, balance < comission_size); ;; insufficient funds
    throw_unless(103, sender_address.slice_hash() == sc_address.slice_hash()); ;; permission denied
    
    ;; TODO: none of 2 transactions are getting sent, must be debugged
    compose_comission_payment(master_address, comission_size);
    compose_update_message(query_id, actual_value, sc_address);
    
    return();
  }
;; не сделал разделение на ондеманд и субскрип
  throw(0xffff);
}

(int) get_actual_value() method_id {
  (int actual_value, slice owner_address, slice master_address, slice sc_address, int comission_size, cell whitelisted_oracle_addresses, int mode, int interval) = load_data();  
  return (actual_value);
}
