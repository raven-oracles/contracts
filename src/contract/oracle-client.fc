
(int) get_num() inline {
  slice data = get_data().begin_parse();
  return (data~load_uint(64));
}

() send_fees() impure {
  slice add = begin_cell().end_cell().begin_parse(); ;; need to add address of treasure contract
  cell mssage = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(add)
    .store_coins(10000) ;; some fees to pay for fetch
    .store_uint(0, 1 + 1 + 4 + 4 + 64 + 32 + 1)
    .end_cell();
  send_raw_message(mssage, 64);
}

() send_response(int coinPrice, slice add) impure {
  cell mssage = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(add)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
    .store_uint(1, 1)
    .store_ref(begin_cell().store_uint(0, 32).store_uint(coinPrice, 64).end_cell())
    .end_cell();
  send_raw_message(mssage, 64);
}

;; on deploy we need to store oracle sercer wallet address inside c4
;; and also store user smart contract address as well

;; testable
() recv_internal (cell in_msg, slice in_msg_body) impure {
  slice cs = in_msg.begin_parse();
  cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  ;; oracle client sc on recv_internal get some data from server and then stores it
  int op = in_msg_body~load_uint(32);
  ~dump(op);  
  if (op == op::update()) { ;; need to add address checker
    int coinPrice = in_msg_body~load_uint(64);
    cell data = begin_cell().store_uint(coinPrice, 64).end_cell();
    set_data(data);
  }
  
  if (op == op::fetch()) {
    ;; need to add address checker (if requesting add is the same as stored add)
    int coinPrice = get_num();
    ;;send_fees();
    ;; need to add address of user contract load from c4
    send_response(coinPrice, sender_address);
  }
  
  ;; when contract will recive msg fo requesting data he will pay the fees to treasure and then send data back
}
