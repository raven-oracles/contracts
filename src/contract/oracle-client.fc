_ load_data() inline {
  slice ds = get_data().begin_parse();
  cell data_field = ds~load_ref();

  var addresses = ds~load_ref().begin_parse();
  slice user_sc_address = addresses~load_msg_addr(); 
  slice master_address = addresses~load_msg_addr();

  int comission_size = ds~load_coins();
  int mode = ds~load_uint(32);
  int interval = ds~load_uint(32);
  int client_id = ds~load_uint(32);

  return (
    data_field,
    user_sc_address,
    master_address,
    comission_size,
    mode,
    interval,
    client_id 
  );
}

_ load_init_data () inline {
  slice ds = get_data().begin_parse();
  slice master_address = ds~load_msg_addr();
  int client_id = ds~load_uint(32);

  return (
    master_address, 
    client_id
  );
}

() save_data (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) impure inline {
  cell data = begin_cell()
      .store_ref(data_field)
      .store_ref(begin_cell().store_slice(user_sc_address).store_slice(master_address).end_cell())
      .store_coins(comission_size)
      .store_uint(mode, 32)
      .store_uint(interval, 32)
      .store_uint(client_id, 32)
    .end_cell();
  set_data(data);
  return();
}

() compose_comission_payment (slice comission_address, int comission_size) impure {
  cell comission_message = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(comission_address)
      .store_coins(comission_size)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .end_cell();
  send_raw_message(comission_message, 64); ;; pay fees
}

() compose_update_message ( int query_id, cell data_field, slice user_sc_address) impure {
  slice update_msg_body = begin_cell().store_uint(op::update(), 32).store_uint(query_id, 64).store_ref(data_field).end_cell().begin_parse();
  cell update_message = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(user_sc_address)
        .store_coins(50000000) ;; TODO check this one / do we need to send 0.05TON with mode 64??? find alternative
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_slice(update_msg_body)
        .end_cell();
  send_raw_message(update_message, 64); 
}

() compose_withdrawal (slice user_sc_address, int withdrawal_amount) impure {
  cell mssage = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(user_sc_address)
    .store_coins(withdrawal_amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .end_cell();
  send_raw_message(mssage, 64); 
}

() recv_internal (int my_balance, int msg_value, cell in_msg, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
      return ();
  }

  slice cs = in_msg.begin_parse();
  int flags = cs~load_uint(4);
  
  if (flags & 1) {
      ;; TODO: Finish logic of on bounce
      ;; on_bounce(in_msg_body, msg_value);
      ;; in theory "throw(0xffff)" will be enougth
      return ();
  }

  [int balance, cell balance_cell] = get_balance();
  
  slice sender_address = cs~load_msg_addr();
  var (wc, addr_hash) = parse_std_addr(sender_address);
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);
  
  if (op == op::create_account()) {
    (slice master_address, int client_id) = load_init_data();
  
    throw_unless(103, sender_address.slice_hash() == master_address.slice_hash()); ;; permission denied

    slice user_sc_address = in_msg_body~load_msg_addr();
    int comission_size = in_msg_body~load_coins();
    int mode = in_msg_body~load_uint(32);
    int interval = in_msg_body~load_uint(32);
    cell data_field = in_msg_body~load_ref();
    
    save_data(data_field, user_sc_address, master_address, comission_size, mode, interval, client_id); 

    return();
  }
  
  (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) = load_data();

  if (op == op::new_value()) {
    throw_unless(103, sender_address.slice_hash() == master_address.slice_hash()); ;; permission denied
    cell new_data_field = in_msg_body~load_ref();
    save_data(new_data_field, user_sc_address, master_address, comission_size, mode, interval, client_id); 
    return();
  }

  if (op == op::fetch()) {
    throw_unless(103, sender_address.slice_hash() == user_sc_address.slice_hash()); ;; permission denied
    throw_if(101, balance < comission_size); ;; insufficient funds
    
    ;; TODO: none of 2 transactions are getting sent, must be debugged
    compose_update_message(query_id, data_field, user_sc_address);
    compose_comission_payment(master_address, comission_size);
    
    return();
  }

  if (op == op::withdrawal()) {
    throw_unless(103, sender_address.slice_hash() == user_sc_address.slice_hash()); ;; permission denied 
    int withdrawal_amount = in_msg_body~load_coins();
    throw_unless(101, withdrawal_amount <= my_balance - 1000000);
    compose_withdrawal(user_sc_address, withdrawal_amount); 
    return();                            
  }

  throw(0xffff);
}

(cell, slice, slice, int, int, int, int ) get_client_data() method_id {
  (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) = load_data();  
  return (data_field, user_sc_address, master_address, comission_size, mode, interval, client_id);
}

(cell) get_data_field() method_id {
  (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) = load_data();  
  return (data_field);
}

(int) get_client_id() method_id {
  (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) = load_data();  
  return (client_id);
}

(int) get_data_field_value() method_id {
  (cell data_field, slice user_sc_address, slice master_address, int comission_size, int mode, int interval, int client_id) = load_data();  
  return (data_field.begin_parse().preload_uint(32)); ;; works only for TON price case
}
