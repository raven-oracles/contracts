;; Oracle master smart contract

;; storage scheme
;; storage#_ admin_address:MsgAddress meta_data:^Cell oracle_client_code:^Cell = Storage comission_address:MsgAddress ;

#pragma version >=0.2.0;
const min_to_create_account = 20000000; ;; 0.02 TON

(slice, cell, cell, slice, int, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(), ;; admin_address
        ds~load_ref(), ;; meta_data
        ds~load_ref(), ;; oracle_client_code
        ds~load_msg_addr(), ;; comission_address
        ds~load_coins(),;; comission_size
        ds~load_ref().begin_parse().preload_dict() ;; whitelisted_oracle_addresses
    );
}

cell compose_create_account(int query_id) inline {
    return begin_cell()
        .store_uint(op::create_account(), 32)
        .store_uint(query_id, 64)
        .end_cell();
}

;; TODO: add dict support with whitelisted addresses of sc
() sign_up(int query_id, slice client_owner_addr, cell oracle_client_code, int start_balance, slice sc_address, slice comission_address) impure {
    cell state_init = calculate_oracle_client_state_init(client_owner_addr, my_address(), sc_address, oracle_client_code, comission_address);
    slice to_wallet_address = calculate_oracle_client_address(state_init);
    var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(to_wallet_address)
                .store_coins(start_balance)
                .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
                .store_ref(state_init)
                .store_ref(compose_create_account(query_id));

    ;; TODO: decide who pays for transfer fees
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {
        ;; TODO: Finish logic of on bounce
        ;; on_bounce(in_msg_body, msg_value);
        return ();
    }
    throw_if(79, msg_value < min_to_create_account);

    (slice admin_address, cell meta_data, cell oracle_client_code, slice comission_address, int comission_size, cell whitelisted_oracle_addresses) = load_data();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    slice sc_address = in_msg_body~load_msg_addr();

    int start_balance = msg_value - min_to_create_account;

    ;;TODO: configure proper op codes 
    if (op == op::signup()) {
        sign_up(query_id, sender_address, oracle_client_code, start_balance, sc_address, comission_address);
        return ();
    }

    throw(0xffff);
}

(slice, cell, cell, slice, int, cell) get_oracle_data() method_id {
    (slice admin_address, cell meta_data, cell oracle_client_code, slice comission_address, int comission_size, cell whitelisted_oracle_addresses) = load_data();
    return (admin_address, meta_data, oracle_client_code, comission_address, comission_size, whitelisted_oracle_addresses);
}

slice get_oracle_client_address(slice owner_address, slice sc_address) method_id {
     (slice admin_address, cell meta_data, cell oracle_client_code, slice comission_address, int comission_size, cell whitelisted_oracle_addresses) = load_data();
    return calculate_user_oracle_client_address(owner_address, my_address(), sc_address, oracle_client_code, comission_address) ;
}
